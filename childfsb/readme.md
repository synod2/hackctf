childfsb
---------------
pwn

desc 
---------------

- Format String Bug
- GOT overwrite 

files 
---------------
- childfsb
- libc.so.6(glibc 2.23->ubuntu 16.04)


checksec 
---------------
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

solution 
---------------
fSB문제.
main함수내에서는 0x19바이트만큼 입력을 받는데, 이를 이용한 버퍼 오버플로우등은 불가해보임.
메인함수 내에 내용이 별로 없어보이기 때문에 처음 fsb때는 leak을 하고, 
main함수나 다른 함수 루틴으로 돌아가서 한번 더 fsb를 하는식으로 공격을 구성해야될듯 하다.
스택 출력을 해보면 6번째부터 입력 스택위치에 접근하는게 보이고, 4에서 libc주소를 알아낼 수 있다. 

돌아가는 부분이 문제. 첫 fsb에서 모든걸 해결할수는 없는데다가 카나리까지 걸린 상태.
printf 함수 이후로 호출되는 함수가 있을까? 싶엇는데 카나리가 변조되었을때에 동작하는 stack_chk_fail 함수가 있다.
```
   0x00000000004007ac <+77>:    call   0x4005e0 <printf@plt>
   0x00000000004007b1 <+82>:    mov    eax,0x0
   0x00000000004007b6 <+87>:    mov    rcx,QWORD PTR [rbp-0x8]
   0x00000000004007ba <+91>:    xor    rcx,QWORD PTR fs:0x28
   0x00000000004007c3 <+100>:   je     0x4007ca <main+107>
   0x00000000004007c5 <+102>:   call   0x4005c0 <__stack_chk_fail@plt>
```
해당함수의 got를 main함수로 돌린다음에 카나리에러를 발생시키면 메인함수의 시작점으로 돌아갈 것이다.

libc leak과 got overwrite를 한번에 다 할수는 없어보인다. got부터 덮어씌운 다음에 leak을하자.
바이트수 제한때문에 main으로 바로 가는것도 좀 힘들어보이는 상황.

```
gdb-peda$ x/x 0x601028
0x601028:       0x00000000004005d6
```

got 자리에는 이미 해당 함수의 plt가 들어있는데, 이는 코드영역의 주소이므로 전체를 다 바꾸지 않아도
main함수의 주소로 갈수는 있어보인다. 하위 4바이트만 바꿔준 다음 스택 카나리를 건드리면 stack_chk_fail함수가 실행되면서
main함수로 돌아올 수 있다.

이후 libc를 얻어내고 다시 main으로 돌아온 다음이 문젠데, 
입력값이 한정적이기 때문에 여러번에 나누어 주소값 변조가 이뤄져야 할것처럼 보인다.
보통 이런경우는 setvbuf나 setbuf를 변조해야 하기 때문에 돌아갈 메인 주소를 init 함수가 종료된 이후로 지정해주고, 
여러번에 걸쳐 해당 함수의 got를 바꾼 다음 init 함수를 실행시키는 식으로 진행해보자. 

```
   0x0000000000400748 <+34>:    mov    rax,QWORD PTR [rip+0x200921]        # 0x601070 <stdin@@GLIBC_2.2.5>
   0x000000000040074f <+41>:    mov    esi,0x0
   0x0000000000400754 <+46>:    mov    rdi,rax
   0x0000000000400757 <+49>:    call   0x4005d0 <setbuf@plt>
```

상위 4바이트는 거의 변동이 없으니 하위 8바이트만 바꿔주면 되니까 2번만 더 돌려보면 되는데,
setbuf 함수를 사용하려다보니 문제가 생기는게 stdin의 got가 해당 함수의 첫 인자값으로 들어가고 있어 쉘 실행에 문제가 발생한다. 
stdin의 got를 0으로 덮어씌우면 해결될것 같아 그대로 하니 쉘이 떨어졌다.

근데 이렇게 하니까 리모트에서는 또 안된다. 로컬에서도 어쩔때는 되고 어쩔때는 안된다. 
원샷가젯 대신에 시스템함수의 주소를 사용하는 식으로 진행해봐야겠다. 

계속 안되는 원인이 뭐였는지 찾아보니, 애초에 libc주소를 잘못가져왔다.
로컬에서는 $4 위치에 있는값이 일정할 지 몰라도, 리모트에서는 그런식으론 되지 않았던것.

```
offset = 0x5e4700
payload2 = "%4$lx   "
-> 로컬에선 일정하게 보여도 리모트에선 그렇지 않을 수 있다. 

```
따라서 해당 오프셋을 가져오는 부분을 
스택에서 libc의 주소를 참조하는 구간인 ret 위치의 주소를 받아오는것으로 바꿨다.

```
0048| 0x7fffc7145a58 --> 0x7f7f17845830 (<__libc_start_main+240>:       mov    edi,eax)
offset = 0x20830
payload2 = "%12$lx  "
```

이렇게 하면 원샷가젯을 사용하는 방법과 system 함수를 사용하는 방법 두가지 다 쉘이 떨어진다. 




